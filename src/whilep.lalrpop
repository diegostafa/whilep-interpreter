grammar;

use std::str::FromStr;
use crate::ast::*;

Whitespace: () = r"\s+";
Identifier: String = r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string();
Number: Integer = r"[0-9]+" => FromStr::from_str(<>).unwrap();

pub Stmt: Statement =
{
    TerminalStmt,
    <s1:Stmt> ";" <s2:TerminalStmt> => Statement::Chain(Box::new(s1), Box::new(s2)),
};

TerminalStmt: Statement =
{
    "skip" => Statement::Skip,

    <x:Identifier> ":=" <e:AExpr> => Statement::Assignment{var: x, val: Box::new(e)},
    <x:Identifier> "++" => Statement::Assignment{var:x.clone(), val: Box::new(ArithmeticExpr::Add(Box::new(ArithmeticExpr::Identifier(x.clone())), Box::new(ArithmeticExpr::Number(Integer::Value(1)))))},
    <x:Identifier> "--" => Statement::Assignment{var:x.clone(), val: Box::new(ArithmeticExpr::Sub(Box::new(ArithmeticExpr::Identifier(x.clone())), Box::new(ArithmeticExpr::Number(Integer::Value(1)))))},
    <x:Identifier> "+=" <e:AExpr> => Statement::Assignment{var:x.clone(), val: Box::new(ArithmeticExpr::Add(Box::new(ArithmeticExpr::Identifier(x.clone())), Box::new(e)))},
    <x:Identifier> "-=" <e:AExpr> => Statement::Assignment{var:x.clone(), val: Box::new(ArithmeticExpr::Sub(Box::new(ArithmeticExpr::Identifier(x.clone())), Box::new(e)))},

    "if" <b:BExpr> "then" <s1:Stmt> "end"  => Statement::If{cond:Box::new(b), s1: Box::new(s1), s2: Box::new(Statement::Skip)},
    "if" <b:BExpr> "then" <s1:Stmt> "else" <s2:Stmt> "end"  => Statement::If{cond:Box::new(b), s1: Box::new(s1), s2: Box::new(s2)},

    "while" <b:BExpr> "do" <s:Stmt> "done" => Statement::While{cond: Box::new(b), body: Box::new(s)},

    "repeat" <s:Stmt> "until" <b:BExpr>
        => Statement::Chain(
            Box::new(s.clone()),
            Box::new(Statement::While{
                cond: Box::new(BooleanExpr::Not(Box::new(b))),
                body: Box::new(s.clone())})),

    "for" <x:Identifier> "in"  "[" <from:AExpr> ".."  <to:AExpr> "]" "do" <s:Stmt> "done"
        => Statement::Chain(
            Box::new(Statement::Assignment{var: x.clone(), val: Box::new(from)}),
            Box::new(Statement::While{
                cond: Box::new(BooleanExpr::NumLtEq(Box::new(ArithmeticExpr::Identifier(x.clone())), Box::new(to))),
                body: Box::new(Statement::Chain(
                    Box::new(s),
                    Box::new(Statement::Assignment{
                        var: x.clone(),
                        val: Box::new(ArithmeticExpr::Add(Box::new(ArithmeticExpr::Identifier(x.clone())), Box::new(ArithmeticExpr::Number(Integer::Value(0)))))})))})),
};

AExpr: ArithmeticExpr =
{
    #[precedence(level="1")]
    <x:Identifier>                      => ArithmeticExpr::Identifier(x),
    <n:Number>                          => ArithmeticExpr::Number(n),

    #[precedence(level="2")]
    <x:Identifier> "++" => ArithmeticExpr::PostIncrement(x),
    <x:Identifier> "--" => ArithmeticExpr::PostDecrement(x),


    #[precedence(level="4")]
    "(" <l:AExpr> "*" <r:AExpr> ")" => ArithmeticExpr::Mul(Box::new(l), Box::new(r)),
    "(" <l:AExpr> "/" <r:AExpr> ")" => ArithmeticExpr::Div(Box::new(l), Box::new(r)),

    #[precedence(level="5")]
    "(" <l:AExpr> "+" <r:AExpr> ")" => ArithmeticExpr::Add(Box::new(l), Box::new(r)),
    "(" <l:AExpr> "-" <r:AExpr> ")" => ArithmeticExpr::Sub(Box::new(l), Box::new(r)),
    "[" <l:AExpr> "," <r:AExpr> "]" => ArithmeticExpr::Interval(Box::new(l), Box::new(r)),
    "-" <a:AExpr> => ArithmeticExpr::Sub(Box::new(ArithmeticExpr::Number(Integer::Value(0))), Box::new(a)),
};

BExpr: BooleanExpr =
{
    #[precedence(level="1")]
    "true"                      => BooleanExpr::True,
    "false"                     => BooleanExpr::False,

    #[precedence(level="3")]
    "!" <e:BExpr>                       => BooleanExpr::Not(Box::new(e)),
    "(" <l:BExpr> "&&" <r:BExpr> ")"    => BooleanExpr::And(Box::new(l),Box::new(r)),
    "(" <l:BExpr> "||" <r:BExpr> ")"    => BooleanExpr::Or(Box::new(l),Box::new(r)),
    "(" <l:AExpr> "==" <r:AExpr> ")"    => BooleanExpr::NumEq(Box::new(l), Box::new(r)),
    "(" <l:AExpr> "!=" <r:AExpr> ")"    => BooleanExpr::NumNotEq(Box::new(l), Box::new(r)),
    "(" <l:AExpr> "<" <r:AExpr> ")"     => BooleanExpr::NumLt(Box::new(l), Box::new(r)),
    "(" <l:AExpr> ">" <r:AExpr> ")"     => BooleanExpr::NumGt(Box::new(l), Box::new(r)),
    "(" <l:AExpr> "<=" <r:AExpr> ")"    => BooleanExpr::NumLtEq(Box::new(l), Box::new(r)),
    "(" <l:AExpr> ">=" <r:AExpr> ")"    => BooleanExpr::NumGtEq(Box::new(l), Box::new(r)),

};